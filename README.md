# dz_10
## Практическое задание 10.
## "Решение задач оптимизации с помощью динамического программирования""
### Студент Крылов Эдуард Васильевич
### Дата: 23.12.2025г.

---
В этом разделе представлены реализации четырёх ключевых алгоритмов динамического программирования с подробными пояснениями.

---
## 1. Задача о рюкзаке (0/1 Knapsack)
### Описание алгоритма

Алгоритм решает классическую **задачу о рюкзаке** методом динамического программирования. 

**Условие задачи:**  
Необходимо выбрать набор предметов с максимальной суммарной стоимостью при ограничении на общий вес (вместимость рюкзака). Каждый предмет можно взять только один раз.

**Входные данные:**
- $W$ — максимальная вместимость рюкзака (целое число);
- $n$ — количество предметов;
- Для каждого предмета $i$:
  - $w_i$ — вес предмета;
  - $v_i$ — стоимость предмета.

**Выходные данные:**  
Максимальная суммарная стоимость предметов, которые можно поместить в рюкзак.

### Принцип работы

Используется двумерная таблица динамического программирования $dp[i][w]$, где:
- $i$ — количество рассмотренных предметов (от $0$ до $n$);
- $w$ — текущий вес (от $0$ до $W$).

**Рекуррентное соотношение:**
$$
dp[i][w] = 
\begin{cases} 
0, & \text{если } i = 0 \text{ или } w = 0; \\
dp[i-1][w], & \text{если } w_i > w; \\
\max(dp[i-1][w],\ dp[i-1][w - w_i] + v_i), & \text{иначе.}
\end{cases}
$$

**Шаги алгоритма:**
1. Инициализировать таблицу $dp$ размером $(n+1) \times (W+1)$ нулями.
2. Для каждого предмета $i$ от $1$ до $n$:
   - Для каждого возможного веса $w$ от $1$ до $W$:
     - Если вес предмета $w_i$ превышает текущий вес $w$, взять значение из предыдущей строки: $dp[i][w] = dp[i-1][w]$.
     - Иначе выбрать максимум между:
       - Не брать предмет: $dp[i-1][w]$;
       - Взять предмет: $dp[i-1][w - w_i] + v_i$.
3. Результат — значение $dp[n][W]$.

### Пример

**Вход:**  
$W = 50$, $n = 3$  
Предметы:  
- Предмет 1: $w_1 = 10$, $v_1 = 60$  
- Предмет 2: $w_2 = 20$, $v_2 = 100$  
- Предмет 3: $w_3 = 30$, $v_3 = 120$  

**Выход:**  
Максимальная стоимость: $220$ (предметы 2 и 3).

### Сложность алгоритма

- **Временная сложность:** $O(n \cdot W)$;
- **Пространственная сложность:** $O(n \cdot W)$.

---
## 2. Наибольшая общая подпоследовательность (LCS)

## Алгоритм нахождения длины наибольшей общей подпоследовательности (LCS)

### Описание

Функция `lcs_length` реализует алгоритм динамического программирования для нахождения длины **наибольшей общей подпоследовательности** (Longest Common Subsequence, LCS) двух строк.

**Подпоследовательность** — это последовательность, которая может быть получена из исходной путём удаления некоторых элементов без изменения порядка оставшихся.

### Постановка задачи

**Входные данные:**
- Две строки: $X$ длиной $m$ и $Y$ длиной $n$.

**Выходные данные:**
- Целое число — длина наибольшей общей подпоследовательности строк $X$ и $Y$.

### Принцип работы

Используется двумерная таблица динамического программирования $dp[i][j]$, где:
- $i$ — длина префикса строки $X$ (от $0$ до $m$);
- $j$ — длина префикса строки $Y$ (от $0$ до $n$).

**Рекуррентное соотношение:**
$$
dp[i][j] = 
\begin{cases} 
0, & \text{если } i = 0 \text{ или } j = 0; \\
dp[i-1][j-1] + 1, & \text{если } X[i-1] = Y[j-1]; \\
\max(dp[i-1][j],\ dp[i][j-1]), & \text{иначе.}
\end{cases}
$$

**Шаги алгоритма:**
1. Создать таблицу $dp$ размером $(m+1) \times (n+1)$ и инициализировать нулями.
2. Для каждого $i$ от $1$ до $m$:
   - Для каждого $j$ от $1$ до $n$:
     - Если символы совпадают ($X[i-1] = Y[j-1]$), то:  
       $dp[i][j] = dp[i-1][j-1] + 1$.
     - Иначе взять максимум из соседних значений:  
       $dp[i][j] = \max(dp[i-1][j],\ dp[i][j-1])$.
3. Результат — значение $dp[m][n]$.

---
**Пример:**

|     | ""  | A | E | D | F | H | R |
|-----|---|---|---|---|---|---|---|
|  "" | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| A   | 0 | 1 | 1 | 1 | 1 | 1 | 1 |
| B   | 0 | 1 | 1 | 1 | 1 | 1 | 1 |
| C   | 0 | 1 | 1 | 1 | 1 | 1 | 1 |
| D   | 0 | 1 | 1 | 2 | 2 | 2 | 2 |
| G   | 0 | 1 | 1 | 2 | 2 | 2 | 2 |
| H   | 0 | 1 | 1 | 2 | 2 | 3 | 3 |


---


**Выход:**  
Длина LCS = $3$ (подпоследовательность "ADH").

### Сложность алгоритма

- **Временная сложность:** $O(m \cdot n)$ — требуется заполнить таблицу размером $(m+1) \times (n+1)$.
- **Пространственная сложность:** $O(m \cdot n)$ — для хранения таблицы $dp$.

### Оптимизация памяти

Если требуется только длина LCS (без восстановления самой подпоследовательности), можно сократить пространственную сложность до $O(\min(m, n))$, храня только две последние строки таблицы.


**Вход:**  
$X = \text{"ABCDGH"}$ ($m = 6$)  
$Y = \text{"AEDFHR"}$ ($n = 6$)

**Процесс заполнения таблицы (фрагмент):**  

---
## 3. Разбиение числа на сумму (число разбиений)

## Алгоритм подсчёта числа разбиений натурального числа


### Описание

Функция `count_partitions` реализует алгоритм динамического программирования для нахождения количества способов разбить натуральное число $n$ на сумму натуральных слагаемых.


**Разбиение числа** — представление числа $n$ в виде суммы одного или нескольких натуральных чисел (слагаемых), при этом порядок слагаемых не учитывается.


### Постановка задачи

**Входные данные:**
- Натуральное число $n$ (разбиваемое число).

**Выходные данные:**
- Целое число — количество различных разбиений числа $n$.


### Принцип работы

Используется одномерный массив динамического программирования $dp$, где $dp[i]$ — количество разбиений числа $i$.


**Базовый случай:**  
$dp[0] = 1$ (единственное разбиение нуля — пустое множество).


**Рекуррентное соотношение:**  
Для каждого числа $i$ от $1$ до $n$ и для каждого возможного слагаемого $j$ от $1$ до $i$:  
$$
dp[i] = dp[i] + dp[i - j]
$$

**Шаги алгоритма:**
1. Создать массив $dp$ длиной $n+1$ и инициализировать нулями.
2. Установить $dp[0] = 1$.
3. Для каждого $i$ от $1$ до $n$:
   - Для каждого $j$ от $1$ до $i$:
     - Обновить $dp[i] = dp[i] + dp[i - j]$.
4. Результат — значение $dp[n]$.


### Оптимизированная версия (через производящие функции)

Существует более эффективный подход с использованием производящих функций, где:
$$
P(n) = \sum_{k=1}^{n} (-1)^{k+1} \left[ P\left(n - \frac{k(3k-1)}{2}\right) + P\left(n - \frac{k(3k+1)}{2}\right) \right]
$$
с базовым случаем $P(0) = 1$. Этот метод имеет асимптотику $O(n\sqrt{n})$.

### Пример

**Вход:** $n = 5$

**Все разбиения числа 5:**
1. $5$
2. $4 + 1$
3. $3 + 2$
4. $3 + 1 + 1$
5. $2 + 2 + 1$
6. $2 + 1 + 1 + 1$
7. $1 + 1 + 1 + 1 + 1$


**Выход:** $7$ (количество разбиений).

### Сложность алгоритма

- **Временная сложность базовой версии:** $O(n^2)$ — требуется заполнить массив размером $n+1$, для каждого элемента выполняется до $n$ операций.
- **Пространственная сложность базовой версии:** $O(n)$ — для хранения массива $dp$.
- **Временная сложность оптимизированной версии:** $O(n\sqrt{n})$
- **Пространственная сложность оптимизированной версии:** $O(n)$


### Примечания

- Число разбиений растёт очень быстро с увеличением $n$ (например, для $n=100$ количество разбиений превышает 190 млн).
- Для больших значений $n$ рекомендуется использовать оптимизированный алгоритм через производящие функции.
- Порядок слагаемых в разбиении не учитывается (т. е. $3+2$ и $2+3$ считаются одним разбиением).

---
## 4. Алгоритм Флойда-Уоршелла
## Алгоритм Флойда‑Уоршелла

### Описание

Функция `floyd_warshall` реализует **алгоритм Флойда‑Уоршелла** — классический алгоритм динамического программирования для нахождения кратчайших путей между всеми парами вершин во взвешенном графе.

Алгоритм работает как для ориентированных, так и для неориентированных графов с положительными или отрицательными весами рёбер (при отсутствии отрицательных циклов).

### Постановка задачи

**Входные данные:**
- Взвешенный граф $G = (V, E)$, где:
  - $V$ — множество вершин ($|V| = n$);
  - $E$ — множество рёбер с весами $w(u, v)$.
- Матрица смежности $D$ размером $n \times n$, где:
  - $D[i][j] = w(i, j)$, если есть ребро из $i$ в $j$;
  - $D[i][j] = 0$, если $i = j$;
  - $D[i][j] = \infty$, если нет ребра из $i$ в $j$.

**Выходные данные:**
- Матрица кратчайших расстояний $D^*$ размером $n \times n$, где $D^*[i][j]$ — длина кратчайшего пути из вершины $i$ в вершину $j$.
- (Опционально) матрица предков для восстановления самих путей.

### Принцип работы

Алгоритм использует динамическое программирование, последовательно улучшая оценки кратчайших путей с учётом промежуточных вершин.

**Основная идея:**  
Для каждой пары вершин $(i, j)$ и каждой промежуточной вершины $k$ проверяем, можно ли улучшить путь $i \to j$, пройдя через $k$:  
$$
D[i][j] = \min(D[i][j],\ D[i][k] + D[k][j])
$$

**Шаги алгоритма:**
1. Инициализировать матрицу расстояний $D$ входными данными.
2. Для каждой промежуточной вершины $k$ от $0$ до $n-1$:
   - Для каждой пары вершин $(i, j)$:
     - Обновить $D[i][j] = \min(D[i][j],\ D[i][k] + D[k][j])$.
3. Результат — итоговая матрица $D$.

### Псевдокод

function floyd_warshall(D):
n = размер D
for k = 0 to n-1:
for i = 0 to n-1:
for j = 0 to n-1:
if D[i][k] + D[k][j] < D[i][j]:
D[i][j] = D[i][k] + D[k][j]
return D


### Пример

**Вход:** граф с 4 вершинами и матрицей смежности:

D = [
[0, 5, ∞, 10],
[∞, 0, 3, ∞ ],
[∞, ∞, 0, 1],
[∞, ∞, ∞, 0]
]


**Выход:** матрица кратчайших расстояний:

D* = [
[0, 5, 8, 9 ],
[∞, 0, 3, 4 ],
[∞, ∞, 0, 1 ],
[∞, ∞, ∞, 0 ]
]


### Сложность алгоритма

- **Временная сложность:** $O(n^3)$ — три вложенных цикла по $n$ вершин.
- **Пространственная сложность:** $O(n^2)$ — хранение матрицы расстояний.

### Особенности и ограничения

1. **Отрицательные циклы:**  
   - Если в графе есть отрицательный цикл, алгоритм может дать некорректные результаты.
   - Для обнаружения отрицательных циклов после выполнения алгоритма проверяют:  
     $$
     \exists i: D[i][i] < 0
     $$

2. **Восстановление путей:**  
   - Для восстановления самих кратчайших путей дополнительно поддерживают матрицу предков $P$, где $P[i][j]$ — предпоследняя вершина на пути из $i$ в $j$.

3. **Разреженные графы:**  
   - Для разреженных графов (мало рёбер) эффективнее использовать алгоритм Джонсона ($O(VE + V^2 \log V)$).

### Применение

Алгоритм широко используется в:
- Маршрутизации в сетях;
- Анализе социальных графов;
- Оптимизации транспортных потоков;
- Вычислении центральности вершин.

---